<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>ebisu_feature.vol5</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section id="top">
          <h2>std::invokeã¨ã‹std::result_ofã¨ã‹</h2>
          ebisu_feature.cpp vol.5
        </section>

        <section>
          <section>
            <h3>std::result_ofä½¿ã£ã¦ã‚‹äººã¯ã©ã‚Œãã‚‰ã„ã„ã¾ã™ã‹</h3>
            <aside class="notes">ã„ãªã‹ã£ãŸã‚‰ä¸‹</aside>
          </section>
          <section>
            <h3>ã¯ã„ã€ä»Šæ—¥ã®ç™ºè¡¨ã¯ãŠã—ã¾ã„ã§ã™ã€‚</h3>
          </section>
        </section>

        <section>
          <section>
            <h3>std::result_ofã®å•é¡Œç‚¹</h3>
            <a href="https://cplusplus.github.io/LWG/issue2927">LWG-2927</a>
          </section>

          <section>
            <p>std::result_of_t&lt;F(A...)&gt;ã§ã€Fã®å®Ÿä½“fã‚’f(A...)ã§å‘¼ã³å‡ºã—ãŸæ™‚ã®æˆ»ã‚Šå€¤ã®å‹ãŒå¾—ã‚‰ã‚Œã‚‹</p>
            <p>FãŒãƒ¡ãƒ³ãƒé–¢æ•°ã‚„ãƒ¡ãƒ³ãƒå¤‰æ•°ãƒã‚¤ãƒ³ã‚¿ã®å ´åˆã€ç¬¬1å¼•æ•°ã‚’ãã®ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦æ‰±ã†</p>
            <pre><code data-trim data-noescape class="cpp">
using int_fuction = int(*)(int);
std::result_of_t&lt;int_function(int)&gt; // int

struct foo {
  float operator();
};
std::result_of_t&lt;foo()&gt; // float

using foo_member = int foo::*;
std::result_of_t&lt;foo_member(foo)&gt; // int</code></pre>
          </section>

          <section>
            ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ä¸€ä½“ä½•ãŒå‡ºåŠ›ã•ã‚Œã‚‹ï¼Ÿ
            <pre><code data-trim data-noescape class="cpp">
class foo;
using foo_bar = void (foo::*)();
using result_type = std::result_of_t&lt;foo_bar(foo const)&gt;;
std::cout << typeid(result_type).name() << std::endl;</code></pre>
            <a href="https://wandbox.org/permlink/E3CIlweLEQ8jSVIx">result on wandbox</a>
            <aside class="notes">
              non-const member functionã«constã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ã‚‹ã®ã§æœ¬æ¥å‘¼ã¹ã‚‹ã®ã¯ãŠã‹ã—ã„ã¨ã„ã†ã“ã¨
            </aside>
          </section>

          <section>
            <h3>æœ¬æ¥ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ã¹ã</h3>
            <pre><code data-trim data-noescape class="cpp">std::result_of_t&lt;foo_bar(foo const)&gt;</code></pre>ã¯
            <pre><code data-trim data-noescape class="cpp">std::result_of_t&lt;foo_bar(foo)&gt;</code></pre>ãªã®ã§ã€
            éconstãƒ¡ãƒ³ãƒé–¢æ•°<pre><code data-trim data-noescape class="cpp">using foo_bar = void (foo::*)() /* non-const !! */;</code></pre>ãŒå‘¼ã¹ã¦ã—ã¾ã†
          </section>

          <section>
            é–¢æ•°å‹ã‚’ã„ã„æ„Ÿã˜ã«ä½¿ã£ã¦ã—ã¾ã£ãŸçµæœã€éå‚ç…§å‹ã®å¼•æ•°ã®cv-qualifierãŒæ¶ˆãˆã¦ã—ã¾ã†äº‹æ…‹ã«
          </section>

          <section>
            <p>æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã‚‚ã¡ã‚‡ã„ã¡ã‚‡ã„ã‚„ã‚‰ã‹ã—ã¦ã„ã‚‹ã®ãŒè¦‹ã¤ã‹ã£ã¦ã„ã‚‹</p>
            <a href="https://cplusplus.github.io/LWG/issue2017">LWG-2017</a>
            <a href="https://cplusplus.github.io/LWG/issue2021">LWG-2021</a>
            <a href="https://cplusplus.github.io/LWG/issue2767">LWG-2767</a>
            <pre><code data-trim data-noescape class="cpp">
template &lt;typename F, typename... Args&gt;
std::result_of_t&lt;F(Args...)&gt; f(F fun, Args&amp;&amp;... params) {
    return fun(std::forward&lt;Args&gt;(params)...);
}
struct Functor {
    template &lt;typename T&gt;
    T&amp;&amp; operator()(T&amp;&amp; t) const;
};
int main() {
    typedef std::string const Str;
    f(Functor(), Str("1"));
}</code></pre>
          </section>

          <section>
            <pre><code data-trim data-noescape class="cpp">f(Functor(), Str("1"));</code></pre>ãŒ
            <pre><code data-trim data-noescape class="cpp">std::result_of_t&lt;Functor(std::string const)&gt;
f(Functor fun, std::string const&amp;&amp; params)</code></pre>ã«ãªã£ã¦ã€
            <pre><code data-trim data-noescape class="cpp">std::result_of_t&lt;Functor(std::string const)&gt;</code></pre>constãŒæ¶ˆãˆã¦ã€
            <pre><code data-trim data-noescape class="cpp">std::string&amp;&amp; Functor::operator()(std::string&amp;&amp;)</code></pre>
            <pre><code data-trim data-noescape class="cpp">std::string&amp;&amp; f(Functor fun, std::string const&amp;&amp; params)</code></pre>
          </section>

          <section>
            é–¢æ•°æœ¬ä½“ã¯<pre><code data-trim data-noescape class="cpp">return fun(std::forward&lt;Args&gt;(params)...);</code></pre>ãªã®ã§
            <pre><code data-trim data-noescape class="cpp">return fun(std::forward&lt;std::string const&gt;(params)...);</code></pre>ã§ã€
            ã“ã£ã¡ã¯<pre><code data-trim data-noescape class="cpp">std::string const&amp;&amp; Functor::operator()(std::string const&amp;&amp;)</code></pre>ãŒå‘¼ã°ã‚Œã‚‹ã®ã§ã€std::string const&amp;&amp;ã‚’std::string&amp;&amp;ã§è¿”ãã†ã¨ã—ã¦ã‚¨ãƒ©ãƒ¼
          </section>
        </section>

        <section>
          <section>
            <h3>std::invokeã¨std::is_callableã¨std::result_ofã®å•é¡Œç‚¹</h3>
            <a href="https://cplusplus.github.io/LWG/issue2895">LWG-2895</a>
            <a href="https://cplusplus.github.io/LWG/issue2927">LWG-2927</a>
          </section>

          <section>
            <h2>ã‚ã‹ã‚Šã¥ã‚‰ã„ï¼ï¼</h2>
          </section>

          <section>
            C++11ã§<i>INVOKE</i>ã¨ã„ã†ç–‘ä¼¼é–¢æ•°ã‚’å®šç¾©ã—ã¦std::function,std::bind,std::thread,...ãŒã©ã†ã‚„ã£ã¦æ¸¡ã•ã‚ŒãŸé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã®ã‹ã‚’è¦å®šã—ãŸ
            <pre><code data-trim data-noescape class="cpp">
std::function&lt;R(A...)&gt; f = foo; f(a...) // INVOKE(foo, a...)
std::thread th(foo, a...); // INVOKE(foo, a...)
std::bind(foo, _1, _2, ...)(a...) // INVOKE(foo, a...)</pre></code>
          </section>

          <section>
            <p>ã§ã€C++17ã§ãã®<i>INVOKE</i>ã‚’ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–¢æ•°ã¨ã—ã¦æä¾›(std::invoke)ã—ã‚ˆã†ã¨ã„ã†ã“ã¨ã«ãªã£ãŸ</p>
            <p>ãã‚ŒãŒå‘¼ã¹ã‚‹ã‹ã©ã†ã‹ã‚ã‹ã£ãŸã»ã†ãŒä¾¿åˆ©ã§ã¯ï¼Ÿã¨ãªã£ã¦std::is_(nothrow_)callableã‚’ä½œã‚ã†ã£ã¦ãªã£ãŸ</p>
          </section>

          <section>
            <ul>
              <li>é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã¶ã®ãŒ<br/>std::invoke(f, args...)</li>
              <li>é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‘¼ã³å‡ºã›ã‚‹ã‹èª¿ã¹ã‚‹ã®ãŒ<br/>std::is_(nothrow_)callable&lt;F(Args...)&gt;</li>
              <li>é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å‘¼ã³å‡ºã—ãŸçµæœã®å‹ãŒ<br/>std::result_of&lt;F(Args...)&gt;</li>
            </ul>
            <p class="fragment"><i>INVOKE</i>ã®è¦å‰‡ã«å¾“ã†ã‹ã©ã†ã‹ãªã®ã«ã€invokeã ã£ãŸã‚Šcallã ã£ãŸã‚Šresultã ã£ãŸã‚Šã§ç´›ã‚‰ã‚ã—ã„</p>
          </section>
        </section>

        <section>
          <section>
            ãªã®ã§ã€ã“ã“ã‚‰ã¸ã‚“ä¸€å›æ•´ç†ã—ã¾ã—ã‚‡ã†ã£ã¦ãªã£ãŸ
          </section>

          <section>
            <ul>
              <li><i>INVOKE</i>ã¨std::invokeã¯ãã®ã¾ã¾å¤‰ã‚ã‚‰ãš</li>
              <li>std::is_(nothrow_)callable&lt;F(Args...)&gt;ã¯std::is_(nothrow_)invocable(_r)&lt;F, Args...&gt;</li>
              <li>std::result_of&lt;F(Args...)&gt;ã¯std::invoke_result&lt;F, Args...&gt;</li>
            </ul>
            <p>å…¨ã¦ã«invokeã‚’å…¥ã‚Œã¦çµ±ä¸€</p>
            <p class="fragment">is_invo<mark>c</mark>ableğŸ’¢ğŸ’¢ğŸ’¢</p>
          </section>

          <section>
            std::result_ofã§ã‚ã£ãŸcv-qualifiedã®å•é¡Œã‚‚è§£æ±ºï¼ˆã¡ã‚ƒã‚“ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ï¼‰
            <a href="https://wandbox.org/permlink/GZqZ9KAO2NvCmWub">result on wandbox</a>
          </section>

          <section>
            <h3>ã¨ã„ã†ã“ã¨ã§ã€std::result_ofã¯C++17ã‹ã‚‰deprecatedãªã®ã§ã€std::invoke_resultã‚’ä½¿ã„ã¾ã—ã‚‡ã†</h3>
          </section>
        </section>

        <section>
          <h2>&lt;functional&gt;ã®ãã®ä»–ã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ</h2>
        </section>

        <section>
          <section>
            <h3>std::applyã®è¿½åŠ </h3>
          </section>

          <section>
            std::tupleã®å„è¦ç´ ã‚’å¼•æ•°ã¨ã—ã¦é–¢æ•°ã‚’å‘¼ã³å‡ºã™
            <pre><code data-trim data-noescape class="cpp">
bool foo(int, char const*, float);

std::tuple args(123, "foo", 456.789f);
bool c = std::apply(foo, args); // foo(123, "foo", 456.789f)</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>std::not_fnã®è¿½åŠ </h3>
          </section>

          <section>
            <p>std::mem_fnãŒC++11ã§è¿½åŠ ã•ã‚ŒãŸã‘ã©ã€ã”ãä¸€éƒ¨åˆ†ã—ã‹ä½¿ãˆãªã„</p>
            <p>ç‰¹ã«Predicateã‚’å—ã‘å–ã‚‹ã‚ˆã†ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§</p>
          </section>

          <section>
            ä¾‹ãˆã°æœ€åˆã«ç©ºã«ãªã‚‹è¦ç´ ã¸ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯
            <pre><code data-trim data-noescape class="cpp">
std::vector&lt;std::string&gt; sv;
auto itr = std::find_if(sv.begin(), sv.end(),
                        std::mem_fn(&std::string::empty));</code></pre>
          </section>

          <section>
            ä¾‹ãˆã°æœ€åˆã«ç©ºã«<mark>ãªã‚‰ãªã„</mark>è¦ç´ ã¸ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯
            <pre><code data-trim data-noescape class="cpp">
std::vector&lt;std::string&gt; sv;
auto itr = std::find_if(sv.begin(), sv.end(),
                        [](auto&amp; s) { return !s.empty(); });</code></pre>
          </section>

          <section>
            ä¾‹ãˆã°æœ€åˆã«ç©ºã«<mark>ãªã‚‰ãªã„</mark>è¦ç´ ã¸ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯
            <pre><code data-trim data-noescape class="cpp">
std::vector&lt;std::string&gt; sv;
auto itr = std::find_if(sv.begin(), sv.end(),
                        std::not_fn(&amp;std::string::empty));</code></pre>
          </section>

          <section>
            <h3>ã†ã‚“ã€generic lambdaã‚ã‚Œã°ãã‚“ãªã«å¤‰ã‚ã‚‰ã‚“ã‹ã‚‚</h3>
          </section>

          <section>
            ä¸€å¿œã€è¿°èªãŒå¤‰æ•°ã¨ã‹ã«ãªã£ã¦ãŸã‚‰çŸ­ãã¯ãªã‚‹
            <pre><code data-trim data-noescape class="cpp">
auto p = []{ ... };
std::find_if(a.begin(), a.end(), std::not_fn(p));
std::find_if(a.begin(), a.end(), [=](auto&amp; v){ return !p(v); });</code></pre>
          </section>
        </section>

        <section>
          <section>
            <h3>C++03æ™‚ä»£ã®éºç‰©ã®å‰Šé™¤ã¨éæ¨å¥¨åŒ–</h3>
          </section>

          <section>
            C++11ã§std::mem_fnã®å°å…¥ã§éæ¨å¥¨åŒ–ã•ã‚ŒãŸã“ã„ã¤ã‚‰ã¯C++17ã§å‰Šé™¤
            <p>std::(unary|binary)_function, std::binder(1st|2nd), std::bind(1st|2nd),
              std::pointer_to_(unary|binary)_function, std::ptr_fun, std::(const_)mem_fun(1)_t, std::mem_fun,
              std::(const_)mem_fun(1)_ref_t, std::mem_fun_ref</p>
          </section>

          <section>
            C++17ã§std::not_fnã®å°å…¥ã§ã“ã„ã¤ã‚‰ã¯C++17ã§éæ¨å¥¨åŒ–
            <p>std::unary_negate, std::binary_negate, std::not1,  std::not2</p>
          </section>
        </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					<!-- { src: 'plugin/markdown/marked.js' }, -->
					<!-- { src: 'plugin/markdown/markdown.js' }, -->
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
